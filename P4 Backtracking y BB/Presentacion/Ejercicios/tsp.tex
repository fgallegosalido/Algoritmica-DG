\subsection{Enunciado}
El problema del viajante de comercio ya se ha comentado y utilizado en la práctica sobre
algoritmos voraces, donde se estudiaron métodos de este tipo para encontrar soluciones razonables (no óptimas necesariamente) a este problema. 
Si se desea encontrar una solución óptima es necesario utilizar métodos más potentes (y costosos), 
como la vuelta atrás y la ramificación y poda, que exploren el espacio de posibles soluciones de forma más exhaustiva.

Así, un algoritmo de vuelta atrás comenzaría en la ciudad $1$ (podemos suponer sin pérdida
de generalidad, al tratarse de encontrar un tour, que la ciudad de inicio y fin es esa ciudad) e
intentaría incluir como parte del tour la siguiente ciudad aún no visitada, continuando de este
modo hasta completar un tour. Para agilizar la búsqueda de la solución se deben considerar como
ciudades válidas para una posición (ciudad actual) sólo aquellas que satisfagan las restricciones
del problema (en este caso ciudades que aún no hayan sido visitadas). Cuando para un nivel
no queden más ciudades válidas, el algoritmo hace una vuelta atrás proponiendo una nueva
ciudad válida para el nivel anterior.

Para emplear un algoritmo de ramificación y poda es necesario utilizar una cota inferior:
un valor menor o igual que el verdadero coste de la mejor solución (la de menor coste) que se
puede obtener a partir de la solución parcial en la que nos encontremos.

Una posible alternativa sería la siguiente: como sabemos cuáles son las ciudades que faltan
por visitar, una estimación optimista del costo que aún nos queda será, para cada ciudad, el
coste del mejor (menor) arco saliente de esa ciudad. La suma de los costes de esos arcos, más
el coste del camino ya acumulado, es una cota inferior en el sentido antes descrito.

Para realizar la poda, guardamos en todo momento en una variable $C$ el costo de la mejor
solución obtenida hasta ahora (que se utiliza como cota superior global: la solución óptima
debe tener un coste menor o igual a esa). Esa variable puede inicializarse con el costo de la
solución obtenida utilizando un algoritmo voraz (como los utilizados en la práctica $2$). Si para
una solución parcial, su cota inferior es mayor que $C$ entonces se puede realizar la poda.

Como criterio para seleccionar el siguiente nodo que hay que expandir del árbol de búsqueda
(la solución parcial que tratamos de expandir), se empleará el criterio LC o ``más prometedor".
En este caso consideraremos como nodo más prometedor aquel que presente el menor valor de
cota inferior. Para ello se debe de utilizar una cola con prioridad que almacene los nodos ya
generados (nodos vivos).

Además de devolver el costo de la solución encontrada (y en su caso el tour correspondiente),
se deben de obtener también resultados relativos a complejidad: número de nodos expandidos,
tamaño máximo de la cola con prioridad de nodos vivos, número de veces que se realiza la poda
y el tiempo empleado en resolver el problema.

Las pruebas del algoritmo pueden realizarse con los mismos datos empleados en la práctica
$2$ (teniendo en cuenta que el tamaño de problemas que se pueden abordar con estas técnicas es
mucho más reducido que con los métodos voraces). La visualización de las soluciones también
puede hacerse de la misma forma que en la práctica $2$ (usando gnuplot).

\subsection{Explicación}
\subsection{Eficiencia}
\subsection{Comparativa}
Comparamos los tiempos gastados con las diferentes formas de hayar cotas inferiores para poda.
\subsection{Conclusión}